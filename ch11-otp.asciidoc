[[OTP]]
Getting Started with OTP
------------------------
In order to help me understand how the +gen_server+ behavior works,
I drew the diagram shown in <<FIG1101>>.

[[FIG1101]]
.Processing a call in +gen_server+ 
image::images/eter_1101.png[float="true"]

The client does a +gen_server::call(Server, Request)+. The server will
then call the +handle_call/3+ function that you have provided in the
+Module+ that you told +gen_server+ to use. +gen_server+ will send your
module the client's +Request+, an identifier telling who the request is
+From+, and the server's current +State+.

Your +handle_call/3+ function will fulfill the client's +Request+ and
send a +{reply, Reply, NewState}+ tuple back to the server. It, in turn,
will send the +Reply+ back to the client, and use the +NewState+ to update
its state.

In _Introducing Erlang_ and in the next two études,
the client is you, using the shell. The module that handles the
client's call is contained within the same module as the +gen_server+
framework, but, as the preceding diagram shows, it does not have to be.

[[CH11-ET01]]
Étude 11-1: Get the Weather
~~~~~~~~~~~~~~~~~~~~~~~~~~~
In this étude, you will create a weather server using the +gen_server+
OTP behavior.This server will handle requests using a four-letter weather
station identifier and will return a brief summary of the weather. You may
also ask the server for a list of most recently accessed weather stations.

Here is some sample output:

----
1> c(weather).
{ok,weather}
2> weather:start_link().
{ok,<0.42.0>}
3> gen_server:call(weather, "KSJC").
{ok,[{location,"San Jose International Airport, CA"},
     {observation_time_rfc822,"Mon, 18 Feb 2013 13:53:00 -0800"},
     {weather,"Overcast"},
     {temperature_string,"51.0 F (10.6 C)"}]}
4> gen_server:call(weather, "KITH").
{ok,[{location,"Ithaca / Tompkins County, NY"},
     {observation_time_rfc822,"Mon, 18 Feb 2013 16:56:00 -0500"},
     {weather,"A Few Clouds"},
     {temperature_string,"29.0 F (-1.6 C)"}]}
5> gen_server:call(weather,"NONE").
{error,404}
6> gen_server:cast(weather, "").
Most recent requests: ["KITH","KSJC"]
----

Obtaining Weather Data
^^^^^^^^^^^^^^^^^^^^^^
To retrieve a web page, you must first call +inets:start/0+; you will
want to do this in your +init/1+ code. Then, simply call
+httpc:request(_url_)+, where +_url_+ is a string containing the URL
you want. In this case, you will use the
server provided by http://www.noaa.gov/[National Oceanic and Atmospheric Administration]. This server accepts four-letter
weather station codes and returns an
XML file summarizing the current weather at that station. You request
this data with a URL in the form

+http://w1.weather.gov/xml/current_obs/_NNNN_.xml+

where +_NNNN_+ is the station code.

If the call to +httpc:request/1+ fails you will get a tuple of the form
+{error,_information_}+.

If it succeeds, you will get a tuple in the form:

[subs="quotes"]
----
{ok,{{"HTTP/1.1",_code_,"_code message_"},
     [{"_HTTP header attribute_","_value_"},
      {"_Another attribute_","_another value_"}],
     "_page contents_"}}
----

where +_code_+ is the return code (200 means the page was found,
404 means it's missing, anything else is some sort of error).

So, let's say you have successfully retrieved a station's data. You will
then get page content that contains something like this:

----
<?xml version="1.0" encoding="ISO-8859-1"?> 
<?xml-stylesheet href="latest_ob.xsl" type="text/xsl"?>
<current_observation version="1.0"
	 xmlns:xsd="http://www.w3.org/2001/XMLSchema"
	 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	 xsi:noNamespaceSchemaLocation="http://www.weather.gov/view/current_observation.xsd">
	<credit>NOAA's National Weather Service</credit>
	<credit_URL>http://weather.gov/</credit_URL>
	<image>
		<url>http://weather.gov/images/xml_logo.gif</url>
		<title>NOAA's National Weather Service</title>
		<link>http://weather.gov</link>
	</image>
	<suggested_pickup>15 minutes after the hour</suggested_pickup>
	<suggested_pickup_period>60</suggested_pickup_period>
	<location>San Jose International Airport, CA</location>
	<station_id>KSJC</station_id>
	<latitude>37.37</latitude>
	<longitude>-121.93</longitude>
	<observation_time>Last Updated on Feb 18 2013, 11:53 am PST</observation_time>
  <observation_time_rfc822>Mon, 18 Feb 2013 11:53:00 -0800</observation_time_rfc822>
	<weather>Overcast</weather>
	<temperature_string>50.0 F (10.0 C)</temperature_string>
	<temp_f>50.0</temp_f>
	<temp_c>10.0</temp_c>
	<relative_humidity>77</relative_humidity>
	<wind_string>Calm</wind_string>
	<wind_dir>North</wind_dir>
	<wind_degrees>0</wind_degrees>
	<wind_mph>0.0</wind_mph>
	<wind_kt>0</wind_kt>
	<pressure_string>1017.7 mb</pressure_string>
	<pressure_mb>1017.7</pressure_mb>
	<pressure_in>30.05</pressure_in>
	<dewpoint_string>43.0 F (6.1 C)</dewpoint_string>
	<dewpoint_f>43.0</dewpoint_f>
	<dewpoint_c>6.1</dewpoint_c>
	<visibility_mi>10.00</visibility_mi>
 	<icon_url_base>http://forecast.weather.gov/images/wtf/small/</icon_url_base>
	<two_day_history_url>http://www.weather.gov/data/obhistory/KSJC.html</two_day_history_url>
	<icon_url_name>ovc.png</icon_url_name>
	<ob_url>http://www.weather.gov/data/METAR/KSJC.1.txt</ob_url>
	<disclaimer_url>http://weather.gov/disclaimer.html</disclaimer_url>
	<copyright_url>http://weather.gov/disclaimer.html</copyright_url>
	<privacy_policy_url>http://weather.gov/notice.html</privacy_policy_url>
</current_observation>
----

Parsing the Data
^^^^^^^^^^^^^^^^

You now have to parse that XML data. Luckily, Erlang comes with the
+xmerl_scan:string/1+ function, which will parse your XML into a rather
imposing-looking tuple. Here is what it looks like for a very simple
bit of XML:

[source, erl]
----
1> XML = "<pets><cat>Misha</cat><dog>Lady</dog></pets>".
"<pets><cat>Misha</cat><dog>Lady</dog></pets>"
3> Result = xmerl_scan:string(XML).
{{xmlElement,pets,pets,[],
     {xmlNamespace,[],[]},
     [],1,[],
     [{xmlElement,cat,cat,[],
                  {xmlNamespace,[],[]},
                  [{pets,1}],
                  1,[],
                  [{xmlText,[{cat,1},{pets,1}],1,[],"Misha",text}],
                  [],
                  "/home/david/etudes/code/ch11-01",
                  undeclared},
      {xmlElement,dog,dog,[],
                  {xmlNamespace,[],[]},
                  [{pets,1}],
                  2,[],
                  [{xmlText,[{dog,2},{pets,1}],1,[],"Lady",text}],
                  [],undefined,undeclared}],
     [],
     "/home/david/etudes/code/ch11-01",
     undeclared},
     []}
----

Ye cats! How you do work with that?! First, put this at the top of your
code so that you can use +xmerl+'s record definitions:

[source, erlang]
----
-include_lib("xmerl/include/xmerl.hrl").
----

You can see all the details of the records at 
http://erlang.googlecode.com/svn-history/r160/trunk/lib/xmerl/include/xmerl.hrl

Then, copy and paste this into your code. You could figure it out
on your own, but that would take away from setting up the server, which is
the whole point of this étude.

[source, erlang]
----
%% Take raw XML data and return a set of {key, value} tuples

analyze_info(WebData) ->
  %% list of fields that you want to extract
  ToFind = [location, observation_time_rfc822, weather, temperature_string],
  
  %% get just the parsed data from the XML parse result
  Parsed = element(1, xmerl_scan:string(WebData)),
  
  %% This is the list of all children under <current_observation>
  Children = Parsed#xmlElement.content,
  
  %% Find only XML elements and extract their names and their text content.
  %% You need the guard so that you don't process the newlines in the
  %% data (they are XML text descendants of the root element).
  ElementList = [{El#xmlElement.name, extract_text(El#xmlElement.content)}
    || El <- Children, element(1, El) == xmlElement],
    
  %% ElementList is now a keymap; get the data you want from it.
  lists:map(fun(Item) -> lists:keyfind(Item, 1, ElementList) end, ToFind).


%% Given the parsed content of an XML element, return its first node value
%% (if it's a text node); otherwise return the empty string.

extract_text(Content) ->
  Item = hd(Content),
  case element(1, Item) of
    xmlText -> Item#xmlText.value;
    _ -> ""
  end.
----

Set up a Supervisor
^^^^^^^^^^^^^^^^^^^
Finally, you can easily crash the server by handing it a number instead
of a string for the station code.  Set up a supervisor to restart the
server when it crashes.

[source, erl]
----
1> c(weather_sup).
{ok,weather_sup}
2> {ok, Pid} = weather_sup:start_link().
{ok,<0.38.0>}
3> unlink(Pid).
true
4> gen_server:call(weather, "KGAI").
{ok,[{location,"Montgomery County Airpark, MD"},
     {observation_time_rfc822,"Mon, 18 Feb 2013 17:55:00 -0500"},
     {weather,"Fair"},
     {temperature_string,"37.0 F (3.0 C)"}]}
5> gen_server:call(weather, 1234).  
** exception exit: {{badarg,[{erlang,'++',[1234,".xml"],[]},
                             {weather,get_weather,2,[{file,"weather.erl"},{line,43}]},
                             {weather,handle_call,3,[{file,"weather.erl"},{line,23}]},
                             {gen_server,handle_msg,5,
                                         [{file,"gen_server.erl"},{line,588}]},
                             {proc_lib,init_p_do_apply,3,
                                       [{file,"proc_lib.erl"},{line,227}]}]},
                    {gen_server,call,[weather,1234]}}
     in function  gen_server:call/2 (gen_server.erl, line 180)

=INFO REPORT==== 18-Feb-2013::15:57:19 ===
    application: inets
    exited: stopped
    type: temporary
6> 
=ERROR REPORT==== 18-Feb-2013::15:57:19 ===
** Generic server weather terminating 
** Last message in was 1234
** When Server state == ["KGAI"]
** Reason for termination == 
** {badarg,[{erlang,'++',[1234,".xml"],[]},
            {weather,get_weather,2,[{file,"weather.erl"},{line,43}]},
            {weather,handle_call,3,[{file,"weather.erl"},{line,23}]},
            {gen_server,handle_msg,5,[{file,"gen_server.erl"},{line,588}]},
            {proc_lib,init_p_do_apply,3,[{file,"proc_lib.erl"},{line,227}]}]}

6> gen_server:call(weather, "KCMI").
{ok,[{location,"Champaign / Urbana, University of Illinois-Willard, IL"},
     {observation_time_rfc822,"Mon, 18 Feb 2013 16:53:00 -0600"},
     {weather,"Overcast and Breezy"},
     {temperature_string,"47.0 F (8.3 C)"}]}
----

<<SOLUTION11-ET01,See a suggested solution in Appendix A.>>

[[CH11-ET02]]
Étude 11-2: Wrapper Functions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
In the previous étude, you made calls directly to +gen_server+. This is
great for experimentation, but in a real application, you do not want
other modules to have to know the exact format of the arguments you gave
to +gen_server:call/2+ or +gen_server:cast/2+. Instead, you provide a
"wrapper" function that makes the actual call. In this way, you can change
the internal format of your server requests while the interface you present
to other users remains unchanged.

In this étude, then, you will provide two wrapper functions
+report/1+ and +recent/0+. The +report/1+ function will take a station name
as its argument and do the appropriate +gen_server:call+; the
+recent/0+ function will do an appropriate +gen_server:cast+. Everything
else in your code will remain unchanged. You will, of course, have to add
+report/1+ and +recent/0+ to the +-export+ list.

Here's some sample output.

[source, erl]
------
1> c(weather).
{ok,weather}
2> weather:start_link().
{ok,<0.45.0>}
3> weather:report("KSJC").
{ok,[{location,"San Jose International Airport, CA"},
     {observation_time_rfc822,"Tue, 26 Feb 2013 17:53:00 -0800"},
     {weather,"Fair"},
     {temperature_string,"56.0 F (13.3 C)"}]}
4> weather:report("XYXY").
{error,404}
5> weather:report("KCMI").
{ok,[{location,"Champaign / Urbana, University of Illinois-Willard, IL"},
     {observation_time_rfc822,"Tue, 26 Feb 2013 19:53:00 -0600"},
     {weather,"Light Rain Fog/Mist"},
     {temperature_string,"34.0 F (1.1 C)"}]}
6> weather:recent().
Most recent requests: ["KCMI","KSJC"]
------

<<SOLUTION11-ET02,See a suggested solution in Appendix A.>>

[[CH11-ET03]]
Étude 11-3: A Simple Multi-User Chat
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
The purpose of this étude is to use a different OTP behavior to
implement a multi-user chat. I spent a fair amount of time trying to
shoehorn a chat into the mold of the +gen_server+ behavior with
multiple clients. That looks a bit like <<FIG1102>>.

[[FIG1102]]
.Multiple clients with +gen_server+ 
image::images/eter_1102.png[float="true"]

This model is great if you have many clients all demanding weather
reports, as in the previous études. None of the clients really needs
to talk to the others; they grab information from the server and off
they go to other things.

I _could_ have used a client/server model, but I the clients would
have to repeatedly ask "Do I have any messages yet?", and the internal
state of the server got more and more complicated the more I thought
about it.

Luckily, OTP has many different behaviors built into it, and the one
that seemed best was the +gen_event+ behavior. <<FIG1103>> shows how it
works.

[[FIG1103]]
.Processing flow in +gen_event+ 
image::images/eter_1103.png[float="true"]

In addition to being able to do calls just as you did in +gen_server+,
you can add event handlers to a +gen_event+ module. When a client calls
+gen_event:notify/2+, it sends the event manager some data in an
+Event+. The event manager then sends the +Event+ and the manager's current
state to all the +Handler+ modules that it knows about.

In the http://www.erlang.org/doc/design_principles/events.html[Erlang
documentation for the +gen_event+ behavior], a typical use of this
behavior would be to have two handlers added to the event manager.
One would log an error to a terminal, and the other would log an error
to a file. Thus, the client would notify the event manager that some
error had occurred, and the manager would let the handlers take care
of the rest.

Now, how does this match up with the chat room? My idea was to
make each person in the room a "handler," and ignore the client altogether.
This means that the handler gets the person's input and notifies the
event manager, which pushes the input to all the other handlers (and
to the originator, who should ignore it!) The result looks like
<<FIG1104>>.

WARNING: This is almost certainly not the way the
creators of OTP intended when they developed +gen_event+. If a student
of mine were to turn in this solution, I would take off 20% of
the points for "abuse of OTP."

[[FIG1104]]
.Using +gen_event+ to create a chat room
image::images/eter_1104.png[float="true"]


