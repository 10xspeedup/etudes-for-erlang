[[STORING-STRUCTURED-DATA]]
Storing Structured Data
-----------------------

[[CH10-ET01]]
Étude 10-1: Using ETS
~~~~~~~~~~~~~~~~~~~~~
In honor of Erlang's heritage as a language designed for
telephony applications, this étude will set up a small
database that keeps track of phone calls.

Part One
^^^^^^^^
Create a file named +phone_records.hrl+ that defines records
with these fields.

The first record type will store information about individual phone calls.
All of the fields will be strings.

* Phone number
* Starting date (month, day, and year)
* Starting time (hours, minutes, and seconds)
* End date (month, day, and year)
* End time (hours, minutes, and seconds)

The second record type will store information about the person associated
with each phone number.

* Phone number
* Last name (family name)
* First name (given name)
* Middle name
* Rate per minute (float)

You may name the records whatever you wish, and you may use any
field names you wish.

Part Two
^^^^^^^^
In a module named +phone_ets+,
create an ETS table for phone calls by reading a file. The function
that does this will be named +setup/1+, and its argument will be the
name of the file containing the data.

Copy the following text into a file named
+call_data.csv+ and save the file in the same directory where you
did part one. 

----
650-555-3326,2013-03-10,09:01:47,2013-03-10,09:05:11
415-555-7871,2013-03-10,09:02:20,2013-03-10,09:05:09
729-555-8855,2013-03-10,09:00:55,2013-03-10,09:02:18
729-555-8855,2013-03-10,09:02:57,2013-03-10,09:03:56
213-555-0172,2013-03-10,09:00:59,2013-03-10,09:03:49
946-555-9760,2013-03-10,09:01:20,2013-03-10,09:03:10
301-555-0433,2013-03-10,09:01:44,2013-03-10,09:04:06
301-555-0433,2013-03-10,09:05:17,2013-03-10,09:07:53
301-555-0433,2013-03-10,09:10:05,2013-03-10,09:13:14
729-555-8855,2013-03-10,09:04:40,2013-03-10,09:07:29
213-555-0172,2013-03-10,09:04:26,2013-03-10,09:06:00
213-555-0172,2013-03-10,09:06:59,2013-03-10,09:10:35
946-555-9760,2013-03-10,09:03:36,2013-03-10,09:04:23
838-555-1099,2013-03-10,09:00:43,2013-03-10,09:02:44
650-555-3326,2013-03-10,09:05:48,2013-03-10,09:09:08
838-555-1099,2013-03-10,09:03:43,2013-03-10,09:06:26
838-555-1099,2013-03-10,09:07:54,2013-03-10,09:10:10
301-555-0433,2013-03-10,09:14:07,2013-03-10,09:15:08
415-555-7871,2013-03-10,09:06:15,2013-03-10,09:09:32
650-555-3326,2013-03-10,09:10:12,2013-03-10,09:13:09
----

So, how do you read a file? Take just the first three lines,
and put them into a file called +smallfile.csv+, then do the following
commands from +erl+

[source, erl]
-----
1> {ResultCode, InputFile} = file:open("smallfile.csv", [read]).
{ok,<0.33.0>}
2> io:get_line(InputFile, "").
"650-555-3326,2013-03-10,09:01:47,2013-03-10,09:05:11\n"
3> io:get_line(InputFile, "").
"415-555-7871,2013-03-10,09:02:20,2013-03-10,09:05:09\n"
4> io:get_line(InputFile, "").
"729-555-8855,2013-03-10,09:00:55,2013-03-10,09:02:18\n"
5> io:get_line(InputFile, "").
eof
6> file:open("nosuchfile", [read]).
{error,enoent}
----

In the preceding example, lines 1 through 5 show how to open a file
and read it. You can tell you are at the end of file when you get an
atom (+eof+) instead of a list (remember, Erlang strings are lists).
Line 6 shows what happens if you try to open a file
that doesn't exist.

The phone number is the key for this data. Since there are multiple
calls per phone number, you will need a +bag+ type table. 
To get the individual items from each line, use
+re:split/2+, much as you did in <<CH05-ET02,Étude 5-2>>.

Part Three
^^^^^^^^^^
Write functions to summarize the number of minutes for a single
phone number (+summary/1+) or for all phone numbers.
(+summary/0+). These functions return a list of tuples in the form:

+[{_phoneNumber1_, _minutes_]},{_phoneNumber2_, _minutes_}, ...]+

You could write your own code to do time and date calculations to
figure out the duration of a phone call, but there's a limit on how
much you really want to re-invent the wheel, especially with something
as complex as calendar calculations. Consider, for example, a call that
begins on 31 December 2013 at 11:58:36 p.m. and ends on 1 January 2014 at
12:14:22 p.m. I don't even want to think about calls that start on
28 February and go to the next day.

So, instead, use the +calendar:datetime_to_gregorian_seconds/1+ function
to convert a date and time to the number of seconds since the year zero.
(I swear I am not making this up.) The argument to this function is a
tuple in the form:

[subs="quotes"] 
-----
{{_year_, _month_, _day_}, {_hours_, _minutes_, _seconds_}} %% for example
{{2013, 07, 14}, {14, 49, 21}}
-----

Round up any number of seconds to the next minute for ech call. Thus, if
a call lasts 4 minutes and 6 seconds, round it up to 5 minutes.
Hint: add 59 to the total number of seconds before you +div 60+.

NOTE: Now might be the time to rewrite part two so that your dates and times
are stored in the appropriate format. That way, you do the conversion
from string to tuple only once, instead of every time you ask
for a summary.

Here is the sample output.

[source, erl]
-----
1> c(phone_ets).
{ok,phone_ets}
2> phone_ets:setup("call_data.csv").
ok
3> phone_ets:summary("415-555-7871").
[{"415-555-7871",7}]
4> phone_ets:summary().
[{"946-555-9760",3},
 {"415-555-7871",7},
 {"729-555-8855",6},
 {"301-555-0433",12},
 {"213-555-0172",9},
 {"650-555-3326",11}]
-----

[[CH10-ET02]]
Étude 10-2: Using Mnesia
~~~~~~~~~~~~~~~~~~~~~~~~
In this étude, you will use query list comprehensions to join data
from two tables in a Mnesia database of veterinarian appointments for cats.

Part One
^^^^^^^^
You will need two types of records, which you will describe in a
file named +cat_records.hrl+.

The first record type will store information about the cats and their
owners.

* Cat's ID number (this is the key)
* Cat's name
* Owner's name

The second record type contains the appointments.

* Appointment ID number (this is the key)
* Appointment date in form _yyyy-mm-dd_
* Cat's ID number


You may name the records whatever you wish, and you may use any
field names you wish, and if you prefer other file names, you may change those.

Part Two
^^^^^^^^
In a module named +cat_db+,
create the Mnesia tables for the two files. The function
that does this will be named +setup/2+, and its arguments will be the
names of the file containing the data.

Here is the data for the cats, which you can put
in a file named +cats.csv+.

----
1,Marco,David Evans
2,Jasper,David Evans
3,Boris,Cathy King
4,Natasha,Cathy King
5,Izzy,Sachiko Morita
6,Romeo,Sachiko Morita
7,Kaz,Sachiko Morita
8,Autumn,Esteban Espinoza
9,Winter,Esteban Espinoza
10,Spot,Truong Tran
11,Bob,Truong Tran
----

Here is the data for the appointments, which you can put in a
file named +appointments.csv+.

----
1,2013-06-03,2
2,2013-06-03,10
3,2013-06-04,5
4,2013-06-04,7
5,2013-06-04,8
6,2013-06-05,9
7,2013-06-05,3
8,2013-06-06,4
9,2013-06-06,1
10,2013-06-06,6
11,2013-06-06,11
----

NOTE: You could write two functions that all open a file, read data,
split it into fields, write the data to the Mnesia table, and then keep
going until end-of-file. These would share a lot of common code. Instead,
try writing just one function that does the reading, and pass a higher-order
function to it to do the appropriate "split-and-write" operation.


Part Three
^^^^^^^^^^
Write a function named +list_appointments/3+ that takes a year, month, and day
as its arguments. It produces a list of cats and their owners' names for
all people who have appointments on the given day. Use a query list
comprehension to join the tables.

Hint: Get all the appointments and cats, where:

* The appointment date is the given day
* The cat's ID in the appointment equals the ID in the cat's record

Here is some sample output:

[source,erl]
----
1> c(cat_db).
{ok,cat_db}
2> cat_db:setup("cats.csv", "appointments.csv").
Transaction result {atomic,ok}
Transaction result {atomic,ok}
ok
3> cat_db:list_appointments(2013, 6, 4).
[{"Izzy","Sachiko Morita"},
 {"Kaz","Sachiko Morita"},
 {"Autumn","Esteban Espinoza"}]
4> cat_db:list_appointments(2013, 6, 2).
[]
5> cat_db:list_appointments(2013, 6, 3).
[{"Jasper","David Evans"},{"Spot","Truong Tran"}]
----

NOTE: You may have noticed that the list of cat and owner names could have been
normalized into two separate tables. If you do the normalization, you will then have to
join from three tables, and Erlang will complain that joins from more than two
tables are not efficient.

